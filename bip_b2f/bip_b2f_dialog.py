# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BIPbygg2FastDialog
                                 A QGIS plugin
 Connects each byggnad to the associated property 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-07-11
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Andrew Mercer
        email                : mercerraa@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

from qgis.core import (
    Qgis,
    QgsVectorLayer,
    QgsFields,
    QgsField,
    QgsFeature,
    QgsFeatureSink,
    QgsProject,
    NULL,
    QgsLayerTreeLayer,
    QgsExpression,
    QgsGeometry,
    QgsFeatureRequest,
    QgsMessageLog,
    QgsSpatialIndex,
    QgsWkbTypes
)
from qgis.PyQt.QtCore import QVariant
import re
from osgeo import ogr
import logging
from datetime import datetime



# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'bip_b2f_dialog_base.ui'))

count = 1

class BIPbygg2FastDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(BIPbygg2FastDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.OKbb.accepted.connect(self.checkQuery)

        formatter = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        cpath = os.getcwd()
        QgsMessageLog.logMessage(f'cwd: {cpath}', 'BTF', Qgis.Info)
        current_datetime = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = 'BIPbygg2Fast_' + str(current_datetime) + '.log'
        logfilename = os.path.join(cpath, filename )
        QgsMessageLog.logMessage(f'log: {logfilename}', 'BTF', Qgis.Info)
        """ if os.path.isfile(logfilename):
            with open(logfilename, 'w') as file:
                logging.basicConfig(filename=logfilename, level=logging.DEBUG, filemode='w', encoding='utf-8', format=formatter)
                logging.info("Logging of BIPbygg2Fast")  """
                    
        with open(logfilename, 'w') as file:
            logging.basicConfig(filename=logfilename, level=logging.NOTSET, filemode='a', encoding='utf-8', format=formatter)
            logging.info("Logging of BIPbygg2Fast")
            logging.info(logfilename)

    def checkQuery(self):
        byggnadLayer = self.byggnadMapLayerComboBox.currentLayer()
        byLayer = self.byMapLayerComboBox.currentLayer()
        ayLayer = self.ayMapLayerComboBox.currentLayer()
        bufferDistance = self.bufferSizeSpinBox.value()
        bufferPoints = self.bufferPointsQgsSpinBox.value()

        # This is for the user to understand errors in output. 0, 1, 2, 3
        userLogging = 0

        # Set up some variables to be used in later functions
        byggMatch = {}
        # Get coordinate system of a layer (should be identical for all)
        crs = ayLayer.crs().toWkt()
        # Attribute name to group by
        attribute_name = 'FNR_FDS'
        id_name = 'id'
        fastnyck_name = 'fastighetsnyckel'
        anlaggning_id_name = 'anlaggning_id'
        fast_bygg_uuid_name = 'fast_byg_uuid'
        att_names = [attribute_name, id_name, fastnyck_name, anlaggning_id_name, fast_bygg_uuid_name]
        logging.debug(f"crs: {crs}")
        logging.debug(f"att_names: {att_names}")
        time_now = datetime.now().strftime("%H%M%S")
        logging.debug(f"{time_now}")
        #QgsMessageLog.logMessage(f'crs: {crs}', 'BTF', Qgis.Info)
        pc_yes = False
        if pc_yes == True:
            # Set up new layer for points to be used by addPoint()
            point_check = QgsVectorLayer(f'Point?crs={crs}', 'point_check', 'memory')
            pr_point = point_check.dataProvider()

        ##################################################################################################################

        def mergeAY():
            """This function reads the FNR_FDS attribute and merges all polygons with identical FNR_FDS numbers into one object.
            23.08.2024 rewrite: Cannot reasonably handle large data sets and must filter for only relevant objects.
            New problem: There are ay objects with FNR_FDS == 0. These have attributes like 'TRAKT: OUTRETT OMRÅDE', 'OMRTYP: Oregistrerad samfällighet'.
            Stockholms skärgård has many such ay."""
            # Create a dictionary to hold grouped geometries
            grouped_geometries = {}

            ay_near_bygg = []
            # Select only those ay objects near enough to a RAÄ byggnad to be considered as possible targets
            for bygg in byggnadLayer.getFeatures():
                byggBB = bygg.geometry().boundingBox().buffered(50)
                filterRequest = QgsFeatureRequest().setFilterRect(byggBB)
                for proximal_ay in ayLayer.getFeatures(filterRequest):
                    proximal_name = proximal_ay[attribute_name]
                    if proximal_name in [0, '0', '']:
                        proximal_name = proximal_ay['EXTERNID']
                    if proximal_name not in ay_near_bygg:
                        ay_near_bygg.append(proximal_name)
                        #logging.debug(f'ay near byggnad: {proximal_name}')
            logging.debug(f'Total proximal ay: {len(ay_near_bygg)}')
            #time_now = datetime.now().strftime("%H%M%S")
            #logging.debug(f"{time_now}")

            # Iterate through features and group by attribute
            for feature in ayLayer.getFeatures():
                attr_value = feature[attribute_name]
                if attr_value in [0, '0', '']:
                    logging.debug(f'No {attribute_name} found. Using {feature['EXTERNID']} instead.')
                    attr_value = feature['EXTERNID']

                if attr_value not in ay_near_bygg: continue
                # Get the geometry of the feature
                geom = feature.geometry() #makeValid() should not eliminate entire polygons but does, e.g. FNR_FDS 120046601 QgsGeometry.makeValid(feature.geometry())
                if attr_value not in grouped_geometries:
                    grouped_geometries[attr_value] = []
                grouped_geometries[attr_value].append(geom)
                #logging.debug(f'mergeAY(): {attr_value} has {len(grouped_geometries[attr_value])} values')
            # Create a new layer to store the merged multipolygon features
            #crs = ayLayer.crs().toWkt()  # Coordinate Reference System of the original layer
            merged_layer = QgsVectorLayer(f'MultiPolygon?crs={crs}', 'merged_layer', 'memory')

            # Add the group attribute field to the new layer
            pr = merged_layer.dataProvider()
            pr.addAttributes([QgsField(attribute_name, QVariant.String)])
            merged_layer.updateFields()

            # Create a feature for each group and merge the polygons
            for attr_value, geometries in grouped_geometries.items():
                # Merge geometries into one multipolygon
                merged_geometry = QgsGeometry.collectGeometry(geometries)
                #logging.debug(f"Merge att_value: {attr_value}")
                merged_geometry_valid = merged_geometry.makeValid() # makeValid() should not eliminate entire polygons but does, e.g. FNR_FDS 120046601 QgsGeometry.makeValid(merged_geometry)
                if merged_geometry_valid.isNull():
                    err = merged_geometry_valid.lastError()
                    logging.debug(f'{attr_value} Invalid Geometry cannot be fixed: {err}\\n Revert to initial merged object.')
                    merged_geometry_valid = merged_geometry
                # Create a new feature with the merged geometry
                merged_feature = QgsFeature()
                merged_feature.setGeometry(merged_geometry_valid)
                merged_feature.setAttributes([attr_value])

                # Add the feature to the new layer
                pr.addFeature(merged_feature)
            pr.updateExtents()
            pr.createSpatialIndex()

            return merged_layer
        
        #########################################################

        def addData(ay, byggnad, found_ay, byggMatch, id, anlaggning_id, method):
            '''Takes the found fastighet (ay) and byggnad and adds new ay to byggMatch dictionary or appends to existing ay'''
            ayOBJEKT_ID = ay.attributes()[merged_layer.fields().indexFromName(attribute_name)]
            global count # Python bollox, so inconsistent. If I pass count into the function it updates the local not the global. Also pr_point doesn't need passing! https://stackoverflow.com/questions/74412503/cannot-access-local-variable-a-where-it-is-not-associated-with-a-value-but
            logging.debug(f'Byggnad: {count} - id:{id}, anl:{anlaggning_id} to ay:{ayOBJEKT_ID} using {method}')
            if pc_yes == True:
                addPoint(ay, byggnad, method)
            if ayOBJEKT_ID not in found_ay:
                logging.debug(f'{ayOBJEKT_ID} not in found_ay. Making new!')
                byggMatch[ayOBJEKT_ID] = [id],[anlaggning_id],[method]
                count += 1
                return True
            elif ay.attributes()[merged_layer.fields().indexFromName(attribute_name)] in found_ay:
                logging.debug(f'{ayOBJEKT_ID} in found_ay')
                byggMatch[ayOBJEKT_ID][0].append(id)
                byggMatch[ayOBJEKT_ID][1].append(anlaggning_id)
                byggMatch[ayOBJEKT_ID][2].append(method)
                count += 1
                return True
            else:
                return False
            
        def addPoint(ay, byggnad, method):
            '''Creates a new point object from the matches. Not an essential function. Runs only if pc_yes == True:'''
            bid = byggnad.attributes()[byggnad.fields().indexFromName('id')]
            fastighetsnyckel = byggnad.attributes()[byggnad.fields().indexFromName('fastighetsnyckel')]
            fast_byg_uuid = byggnad.attributes()[byggnad.fields().indexFromName('fast_byg_uuid')]
            anlaggning_id = byggnad.attributes()[byggnad.fields().indexFromName('anlaggning_id')]
            ayOBJEKT_ID = ay.attributes()[merged_layer.fields().indexFromName(attribute_name)]
            attributes = [ayOBJEKT_ID, bid, fastighetsnyckel, fast_byg_uuid, anlaggning_id, method, count]
            
            pr_point.addAttributes([QgsField(attribute_name, QVariant.String),\
            QgsField('id', QVariant.String),\
            QgsField('fastighetsnyckel', QVariant.String),\
            QgsField('fast_byg_uuid', QVariant.String),\
            QgsField('anlaggning_id', QVariant.String),\
            QgsField('method', QVariant.String),\
            QgsField('count', QVariant.Int)])
            point_check.updateFields()

            newFeature = QgsFeature()
            newFeature.setGeometry(byggnad.geometry())
            newFeature.setAttributes(attributes)
            pr_point.addFeatures([newFeature])
            pr_point.updateExtents()
            pr_point.createSpatialIndex()

        #########################################################

        def connect2ay():
            for byggnad in byggnadLayer.getFeatures():
                found = False
                found_ay = byggMatch.keys() # list of ay objects already found to have a byggnad

                bfid = byggnad.attributes()[byggnad.fields().indexFromName('fid')]
                bid = byggnad.attributes()[byggnad.fields().indexFromName('id')]
                fastighetsnyckel = byggnad.attributes()[byggnad.fields().indexFromName('fastighetsnyckel')]
                fast_byg_uuid = byggnad.attributes()[byggnad.fields().indexFromName('fast_byg_uuid')]
                anlaggning_id = byggnad.attributes()[byggnad.fields().indexFromName('anlaggning_id')]
                logging.debug(f'RAA byggnad {count} - id:{bid} fn:{fastighetsnyckel}, uuid:{fast_byg_uuid}')
                
                # get ay (fastighet) feature that has FNR_FDS matching fastighetsnyckel. This can fail if fastighetsnyckel no longer current
                if not (fastighetsnyckel == NULL or fastighetsnyckel == ''):        
                    request1 = QgsFeatureRequest().setFilterExpression(' "{}" = \'{}\' '.format(attribute_name, str(fastighetsnyckel)))
                    for ay in merged_layer.getFeatures(request1):
                        found = addData(ay, byggnad, found_ay, byggMatch, bid, anlaggning_id, '1_fastighetsnyckel')
                        if found == True:
                            break        
                
                if found == False and not(re.search('^BeBR-ID', fast_byg_uuid, re.IGNORECASE) or fast_byg_uuid == NULL or fast_byg_uuid == '' ):# if the byggnad has a valid fast_byg_uuid match the byggnad to the ay (fastighet) that the by (LM's byggnad) sits within
                    request2 = QgsFeatureRequest().setFilterExpression(' "{}" = \'{}\' '.format('OBJEKT_ID', str(fast_byg_uuid)))
                    for by in byLayer.getFeatures(request2):
                        byPOS = by.geometry().pointOnSurface()
                        byBB = by.geometry().boundingBox().buffered(200)
                        request3 = QgsFeatureRequest().setFilterRect(byBB)
                        for ay in merged_layer.getFeatures(request3):
                            if byPOS.within(ay.geometry()):
                                found = addData(ay, byggnad, found_ay, byggMatch, bid, anlaggning_id, '2_by_OBJEKT_ID')
                                if found == True: 
                                    break 
                
                if found == False:# If none of the previous, better, methods work check if the point lies within a by (LM's byggnad)
                    byggnadGeometry = byggnad.geometry()
                    byggnadGE = QgsGeometry.createGeometryEngine(byggnadGeometry.constGet())
                    byggnadGE.prepareGeometry()
                    byggBB = byggnad.geometry().boundingBox().buffered(15) # Buffer byggnad point out to 15 m then create bounding box to search
                    request4 = QgsFeatureRequest().setFilterRect(byggBB)
                    
                    for by in byLayer.getFeatures(request4):
                        if byggnadGE.within(by.geometry().constGet()):
                            byGE = QgsGeometry.createGeometryEngine(by.geometry().constGet())
                            byGE.prepareGeometry()
                            byPOS = byGE.pointOnSurface() # Need to deal with within/contains not liking objects touching boundary
                            byPOSgeom = QgsGeometry.createGeometryEngine(byPOS) # There is NO logic in how pyqgis handles geometry objects
                            byBB = by.geometry().boundingBox().buffered(20)
                            request5 = QgsFeatureRequest().setFilterRect(byBB)
                            for ay in merged_layer.getFeatures(request5):
                                if byPOSgeom.within(ay.geometry().constGet()):
                                    found = addData(ay, byggnad, found_ay, byggMatch, bid, anlaggning_id, '3_within_by')
                                    if found == True: 
                                        break
                
                if found == False: # Try pairing a byggnad with a by to pair with an ay
                    bySpatIndex = QgsSpatialIndex(byLayer.getFeatures(request4))
                    nearest_ids = bySpatIndex.nearestNeighbor(byggnadGeometry.asPoint(), 1)
                    if nearest_ids:
                        nearest_id = nearest_ids[0]
                        nearest_by = byLayer.getFeature(nearest_id)
                        byGE = QgsGeometry.createGeometryEngine(nearest_by.geometry().constGet())
                        byGE.prepareGeometry()
                        byPOS = byGE.pointOnSurface()
                        byPOSgeom = QgsGeometry.createGeometryEngine(byPOS)
                        byBB = by.geometry().boundingBox().buffered(200)
                        request6 = QgsFeatureRequest().setFilterRect(byBB)
                        for ay in merged_layer.getFeatures(request6):
                            if byPOSgeom.within(ay.geometry().constGet()):
                                found = addData(ay, byggnad, found_ay, byggMatch, bid, anlaggning_id, '4_snapTo_by')
                                if found == True: 
                                    break 
                runLast = True
                if found == False and runLast == True: # Last resort, pair to nearest ay
                    byggBB = byggnad.geometry().boundingBox().buffered(100) # Buffer byggnad point out to 100 m then create bounding box to search
                    request7 = QgsFeatureRequest().setFilterRect(byggBB)
                    aySpatIndex = QgsSpatialIndex(merged_layer.getFeatures(request7))
                    nearest_ids = aySpatIndex.nearestNeighbor(byggnadGeometry.asPoint(), 1)
                    if nearest_ids:
                        nearest_id = nearest_ids[0]
                        ay = merged_layer.getFeature(nearest_id)
                        found = addData(ay, byggnad, found_ay, byggMatch, bid, anlaggning_id, '5_snapTo_nearest_ay')
                    else:
                        logging.debug('NO MATCH FOUND\n')
            return
        
        #########################################################

        def assigneday():
            # Set up new layer for ay containing byggnad objects
            result_layer = QgsVectorLayer(f'MultiPolygon?crs={crs}', 'resultlayer', 'memory')

            # Add the attribute field to the new layer
            result_pr = result_layer.dataProvider()
            result_pr.addAttributes([QgsField(attribute_name, QVariant.String),\
                                    QgsField('id', QVariant.String),\
                                    QgsField('anlaggning_id', QVariant.String),\
                                    QgsField('method', QVariant.String)])
            result_layer.updateFields()
            logging.debug(f'Number of merged objects: {len(byggMatch.keys())}')
            # Loop through features in layer containing merged ay objects
            for feature in merged_layer.getFeatures():
                attr_value = feature[attribute_name]
                logging.debug(f'Merged object: {attr_value}')
                if attr_value in byggMatch.keys():
                    logging.debug(f'Found in byggMatch')
                    geom = feature.geometry()
                    id = str(byggMatch[attr_value][0])
                    anlaggning_id = str(byggMatch[attr_value][1])
                    method = str(byggMatch[attr_value][2])

                    new_feature = QgsFeature()
                    new_feature.setGeometry(geom)
                    new_feature.setAttributes([attr_value, id, anlaggning_id, method])
                    result_pr.addFeature(new_feature)
                    result_pr.updateExtents()
            result_pr.createSpatialIndex()

            return result_layer

        #########################################################

        def bufferLayer():
            #att_names = [attribute_name, id_name, fastnyck_name, anlaggning_id_name, fast_bygg_uuid_name]
            # Create new layer for buffered ay objects
            buffer_layer = QgsVectorLayer(f'MultiPolygon?crs={crs}', 'buffer', 'memory')
            # Add the attribute field to the new layer
            buffer_pr = buffer_layer.dataProvider()
            buffer_pr.addAttributes([QgsField(att_names[0], QVariant.String),\
                                    QgsField(att_names[1], QVariant.String),\
                                    QgsField(att_names[3], QVariant.String),\
                                    QgsField('method', QVariant.String)])
            buffer_layer.updateFields()
            for feature in result_layer.getFeatures():
                #attr_value = feature[att_names[0]]
                #id = feature[att_names[1]]
                #anlaggning_id = feature[att_names[3]]
                #method = feature['method']
                geom = feature.geometry()
                buffer = geom.buffer(bufferDistance, bufferPoints)
                buffered = QgsFeature()
                buffered.setGeometry(buffer)
                #buffered.setAttributes([attr_value, id, anlaggning_id, method])
                buffered.setAttributes(feature.attributes())
                buffer_pr.addFeature(buffered)
                buffer_pr.updateExtents()
            buffer_pr.createSpatialIndex()
            return buffer_layer

        def splitBuffers():
            return
        ##################################################################################################################

        # Call the function that merges ay polygons
        merged_layer = mergeAY()
        logging.debug(f" Merging ay objects complete")
        #QgsProject.instance().addMapLayer(merged_layer)

        connect2ay()
        logging.debug(f" Connect2ay complete")
        
        # Add results so far to project
        """root = QgsProject.instance().layerTreeRoot()
        groupName = 'Results'
        #newGroup = root.addGroup(groupName)
        newGroup = root.insertGroup(0, groupName)
        toGroup = root.findGroup(groupName)
        QgsProject.instance().addMapLayer(point_check, False)
        toGroup.addLayer(point_check)
        QgsProject.instance().addMapLayer(merged_layer, False)
        toGroup.addLayer(merged_layer)"""

        #QgsProject.instance().addMapLayer(merged_layer)
        if pc_yes == True:
            QgsProject.instance().addMapLayer(point_check)
        
        result_layer = assigneday()
        logging.debug(f' Result complete')
        QgsProject.instance().addMapLayer(result_layer)

        #buffer_layer = bufferLayer()
        #logging.debug(f' Buffering complete')
        #QgsProject.instance().addMapLayer(buffer_layer)
